==1.2. Problème / solution : Singleton== 
===Problèmes fréquents===

*Dépendance globale trop forte (couplage)
Comme tout le programme utilise la même instance, beaucoup de parties du code deviennent dépendantes de Singleton. Cela complique la modification ou l'évolution du projet, car toute modification du Singleton risque d'impacter d'autres segments du programme. Exemple : si le Singleton gère la configuration du site et que chaque page y accède directement, la moindre modification de ce Singleton peut obliger à revoir de nombreuses pages du projet.

*Difficulté à tester 
Le Singleton impose une seule instance pour tout le programme. Cela complique les tests, car on ne peut pas facilement remplacer cette instance par une version simulée. Les tests sont de moins en moins indépendants et plus difficiles à gérer. Exemple : si un Singleton s’occupe de lire des fichiers, on ne peut pas facilement le remplacer par une version “fausse” pour les tests, ce qui oblige à manipuler de vrais fichiers même quand on ne veut pas.

*Risques en multithreading
Si deux threads essayent de créer l’instance au même moment, il peut arriver que deux instances existent temporairement. Cela annule complètement le principe du Singleton et provoque des comportements imprévisibles. Exemple : deux utilisateurs déclenchent en même temps la création d’un Singleton qui gère une connexion à la base de données : deux connexions différentes peuvent être créées alors qu’il ne devrait y en avoir qu’une seule.

*Risques de surcharge ou de mauvaise utilisation
Le Singleton vit pendant toute la durée de l’application. On peut donc être tenté d’y mettre trop de choses “par facilité” : configurations, logs, données temporaires, etc. Il devient alors un “fourre-tout”, difficile à maintenir et à comprendre. Exemple : un Singleton qui devait à l’origine seulement stocker un paramètre finit par contenir des statistiques, des logs, des données utilisateurs… et devient trop lourd.

*Dépendances cachées
Comme il peut être appelé depuis n’importe où, le code semble indépendant, mais dépend en réalité d’un état global partagé. Cela rend le comportement du programme plus difficile à comprendre.

===Solutions===

*Limiter les dépendances
Plutôt que d'utiliser le Singleton de manière directe, nous pourrions le dissimuler derrière des fonctions, des interfaces ou des services. De ce fait, le reste du code s'appuie moins sur le Singleton lui-même, ce qui optimise la structure globale. Exemple : au lieu d’appeler directement “SingletonConfig”, le programme utilise une interface “Config”, ce qui permet de modifier l’implémentation plus facilement.

*Adapter l’usage pour les tests
Il est possible d'établir des procédures de réinitialisation du Singleton dans un environnement de test, ou d'utiliser l'injection de dépendances pour remplacer l’instance par une version simulée. Cela rend les tests plus simples et plus fiables. Exemple : lors des tests, on remplace un Singleton « BaseDeDonnées » par un faux objet qui ne réalise pas de réelles connexions.

*Sécuriser l’accès en multithreading
On utilise des techniques qui garantissent qu’un seul thread peut créer l’instance à la fois. Cela empêche la création accidentelle de plusieurs instances et assure que le modèle reste correct même lorsque plusieurs actions se déclenchent en même temps. Exemple : on bloque la création temporairement pour que, même si deux utilisateurs se connectent en même temps, une seule instance de la ressource soit créée. 

*Limiter ce que le Singleton stocke
Pour éviter qu’il devienne trop lourd, il faut lui donner une seule responsabilité claire et éviter d’y ajouter des données inutiles. Le Singleton doit rester simple et ne pas servir de stockage global permanent. Exemple : si le Singleton est là pour gérer la configuration, il ne doit pas commencer à stocker les logs, les statistiques ou des sessions utilisateurs.

==1.3.Avantages et inconvénients + Variantes==
===Avantages===
*Contrôle strict d’une instance unique
Le Singleton garantit qu’une seule et même instance est utilisée dans toute l’application.
Cela est utile pour des ressources partagées comme : configuration, logs, accès à une base de données, etc.
Exemple : une seule classe Logger pour éviter des conflits d’écriture.

*Accès global facilité
L’instance est accessible de n’importe où via une méthode statique (getInstance()).
Cela simplifie l’accès à des services centraux sans avoir à passer des objets à travers tout le programme.

*Économie de ressources
Au lieu de recréer constamment des objets coûteux (connexion, analyseur, configuration…),
le Singleton permet de n’en charger qu’un seul et de le réutiliser, améliorant ainsi les performances.

*Initialisation contrôlée
On peut décider si l’objet doit être :
**créé immédiatement (eager initialization),
**créé à la première utilisation (lazy initialization),
ce qui optimise l’utilisation de la mémoire.

===Inconvénients===
*Couplage fort au code (dépendance globale)
Le Singleton agit comme une “variable globale améliorée”.
Si trop de classes l’utilisent directement, le code devient rigide et plus difficile à modifier ou à faire évoluer.
Une modification interne du Singleton peut impacter de nombreuses parties du programme.

*Difficultés pour les tests unitaires
Comme le Singleton impose une seule instance, il devient compliqué de :
**le réinitialiser entre deux tests,
**le remplacer par une version simulée (mock).
Cela rend les tests moins indépendants les uns des autres.

*Risques en multithreading
Si le Singleton est mal implémenté, plusieurs threads peuvent créer plusieurs instances simultanément.
Cela annule totalement le concept et peut créer des comportements imprévisibles.

*Risque de “tout mettre dedans”
Souvent, le Singleton finit par devenir une classe fourre-tout, car il est accessible partout.
Cela provoque :
**surcharge,
**manque de lisibilité,
**non-respect du principe de responsabilité unique (SRP).

*Dépendances cachées
Le code peut sembler indépendant, mais utilise en réalité un état global partagé.
Cela rend le comportement du programme plus difficile à comprendre et à prédire.

===Variantes===
Plusieurs implémentations du Singleton existent en Java, chacune adaptée à un contexte différent (performance, simplicité, multithreading…).
====Version 1 : Eager Singleton (Le pressé)====
L’instance est créée dès le chargement de la classe, même si elle n’est jamais utilisée.
*v1 Avantages : 
**simple
**thread-safe par nature.
*v1 Inconvénients : 
**L'instance est créée même si jamais utilisée : peut gaspiller de la mémoire si l’instance est lourde et inutilisée.
---
>public class Singleton {
>    // L'instance est créée immédiatement
>    private static final Singleton INSTANCE = new Singleton();
>    
>    // Constructeur privé : personne ne peut créer d'instance
>    private Singleton() {
>        System.out.println("Chargement de la configuration...");
>        // Lire le fichier de config, initialiser...
>    }
>    
>    // Point d'accès global
>    public static Singleton getInstance() {
>        return INSTANCE;
>    }
>    
>    // Méthodes métier
>    public String getProperty(String key) {
>        // Retourner la valeur de configuration
>    }
>}
---
====Version 2 : Lazy Singleton (Le paresseux - DANGEREUX !)====
L’instance est créée uniquement à sa première utilisation.
*v2 Avantages : 
**créé seulement si besoin.
*v2 Inconvénients : 
**pas thread-safe si utilisé tel quel.

>public class Singleton {
>    private static Singleton instance;
>    
>    private Singleton() {
>        System.out.println("Création du pool de connexions...");
>        // Initialisation coûteuse
>    }
>    
>    // ATTENTION : Cette version a un BUG en multi-thread !
>    public static Singleton getInstance() {
>        if (instance == null) {
>            instance = new Singleton();
>        }
>        return instance;
>    }
>}

Métaphore : C'est comme ne préparer le café que quand quelqu'un en demande. "Lazy" signifie "paresseux". Économique mais risqué !
Le problème critique du Lazy Singleton : Cette version a un bug GRAVE en environnement multi-thread (et tous les programmes modernes sont multi-thread).

Imaginez deux personnes qui arrivent en même temps à la machine à café vide :
>**Alice regarde
>***Pas de café
>**Bob regarde
>***Pas de café
>**Résultat
>***Deux cafetières ! (deux instances)
Ce bug est vicieux car il n'arrive pas toujours. Seulement quand deux threads arrivent au mauvais moment. Impossible à reproduire, cauchemar à débugger !

====Version 3 : Singleton Synchronisé (Le prudent)====
*v3 Avantages :
**Thread-safe : impossible d'avoir deux instances
**Simple à comprendre
*v3 Inconvénient :
**Performance catastrophique ! Après que l'instance est créée, on n'a plus besoin du verrou. Mais synchronized vérifie quand même à CHAQUE appel.
**Si getInstance() est appelée 1 million de fois, vous avez 1 million de vérifications de verrou pour rien !

>public class Singleton {
>    private static Singleton instance;
>    
>    private Singleton() {
>        System.out.println("Création du Singleton...");
>    }
>    
>    // synchronized : un seul thread à la fois peut exécuter cette méthode
>    public static synchronized Singleton getInstance() {
>        if (instance == null) {
>            instance = new Singleton();
>        }
>        return instance;
>    }
>}

Métaphore : C'est comme mettre un vigile devant la machine à café. Une seule personne à la fois peut s'en approcher. Sûr mais lent !

====Version 4 : Double-Checked Locking (L'optimisé)====
La version recommandée : sécurisée + performante.

>public class Singleton {
> // volatile : garantit la visibilité entre threads
> private static volatile Singleton instance;
> 
> private Singleton() {
> System.out.println("Création du Singleton...");
> }
> 
> public static Singleton.getInstance() {
> // Premier check : sans verrou (rapide)
> if (instance == null) {
> // On ne synchronise que si nécessaire
> synchronized (Singleton.class) {
> // Deuxième check : avec verrou (sûr)
> if (instance == null) {
> instance = new Singleton();
> }
> }
> }
> return instance;
> }
>}

====Version 5 : Enum Singleton (Le moderne et élégant)====
Une des meilleures implémentations (simple et thread-safe).

*v5 Avantages :
**garantit l’unicité,
**protège contre la sérialisation,
**impossible de créer plusieurs instances via la réflexion.
*v5 Inconvénient :
**moins flexible si on veut transformer le code plus tard.


>public enum Singleton {
>    INSTANCE; // L'unique instance
>    
>    private Properties properties = new Properties();
>    
>    // Le constructeur d'une enum est appelé une seule fois
>    Singleton() {
>        loadProperties();
>    }
>    
>    private void loadProperties() {
>        // Charger le Singleton
>    }
>    
>    public String getProperty(String key) {
>        return properties.getProperty(key);
>    }
>}
>
>// Utilisation
>String url = Singleton.INSTANCE.getProperty("database.url");

Métaphore : C'est comme utiliser les jours de la semaine. Il n'y a qu'un seul LUNDI, qu'un seul MARDI... La JVM garantit qu'une enum n'a qu'une instance de chaque valeur.




