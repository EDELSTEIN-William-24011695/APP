== Introduction ==
Le '''Visitor Pattern''' (ou visiteur) est un [[patron de conception]] qui permet de séparer les données (vos objets) des opérations (les traitements) que l'on effectue sur elles.

Son objectif principal est de respecter le [[Principe ouvert/fermé]] (''Open/Closed principle'') : permettre d'ajouter de nouvelles fonctionnalités à une application sans avoir à modifier le code des classes existantes.

== Explication ==
Le principe est de séparer les données (les objets) de la logique (les visiteurs). Les objets ne changent pas, mais on déplace les calculs, exports, tris, etc. dans des classes externes (les visiteurs).

Ainsi, on peut utiliser le '''[[Double dispatch]]'''. C’est le visiteur qui va porter l’intelligence du code en demandant à l'objet s'il a le droit d'interagir avec lui :
* On dit à l'objet : « Accepte ce visiteur » (<code>objet.accept(visiteur)</code>).
* L'objet répond au visiteur : « C'est moi, traite-moi » (<code>visiteur.visit(this)</code>).

=== Exemple d'implémentation (Java) ===
Dans cet exemple, nous avons une hiérarchie de formes géométriques (le graphe d'objets) et nous souhaitons ajouter une fonctionnalité d'export XML (le visiteur) sans modifier le code des formes.

'''1. Les Interfaces'''
L'interface Visiteur déclare une méthode de visite pour chaque type d'élément concret, et l'interface de l'Élément déclare la méthode qui accepte le visiteur.

<syntaxhighlight lang="java">
public interface Visitor {
    String visitDot(Dot dot);
    String visitCircle(Circle circle);
}

public interface Shape {
    String accept(Visitor visitor);
}
</syntaxhighlight>

'''2. Les Éléments Concrets'''
Chaque forme concrète implémente la méthode <code>accept</code>. C'est ici que le "Double Dispatch" se produit : l'objet appelle la méthode spécifique du visiteur correspondant à sa propre classe.

<syntaxhighlight lang="java">
public class Dot implements Shape {
    // ... attributs et constructeur ...
    @Override
    public String accept(Visitor visitor) {
        return visitor.visitDot(this); // Le point se désigne lui-même
    }
}

public class Circle implements Shape {
    // ... attributs et constructeur ...
    @Override
    public String accept(Visitor visitor) {
        return visitor.visitCircle(this); // Le cercle se désigne lui-même
    }
}
</syntaxhighlight>

'''3. Le Visiteur Concret'''
C'est ici que réside la logique de l'export XML.

<syntaxhighlight lang="java">
public class XMLExportVisitor implements Visitor {
    @Override
    public String visitDot(Dot d) {
        return "<dot><x>" + d.getX() + "</x></dot>";
    }

    @Override
    public String visitCircle(Circle c) {
        return "<circle><radius>" + c.getRadius() + "</radius></circle>";
    }
}
</syntaxhighlight>

'''4. Code Client'''
Le client assemble les briques.

<syntaxhighlight lang="java">
public class Application {
    public static void main(String[] args) {
        Dot dot = new Dot(1, 10, 55);
        Circle circle = new Circle(2, 23);

        XMLExportVisitor exportVisitor = new XMLExportVisitor();

        // On demande l'export sans que les objets sachent ce qu'est le XML
        System.out.println(dot.accept(exportVisitor));
        System.out.println(circle.accept(exportVisitor));
    }
}
</syntaxhighlight>

== Problème ==
Ce patron est particulièrement utile lorsque des classes sont reliées en [[Graphe (structure de données)|graphe]].

Par exemple, au moment d'une exportation en [[XML]], le programme va chercher à parcourir tous les nœuds du graphe et exécuter l'export à chaque passage sur un nœud. Cependant :
# Cet export, étant une méthode dans le graphe, peut créer des bugs dans le code produit.
# Ce code d’export est vu comme un intrus sémantiquement, puisqu'il n’a rien à voir avec la nature de l'objet créé.

== Solutions possibles ==
Le patron de conception visiteur résout ce problème en utilisant la technique de la **double répartition** (''double dispatch''), qui aide à lancer la bonne méthode sans s’encombrer de blocs conditionnels.

Plutôt que de laisser le client choisir la version de la méthode à appeler, la décision est déléguée aux objets passés en paramètre au visiteur :
* Comme les objets connaissent leur propre classe, ils sont plus à même de choisir la méthode adaptée au visiteur.
* Ils « acceptent » un visiteur et lui indiquent la méthode à exécuter.
* Cela ne nécessite que des changements mineurs dans les classes pour éviter tout bug avec cette nouvelle implémentation.

== Avantages et inconvénients ==

=== Avantages ===
* Il est possible d'ajouter de nouvelles opérations sans modifier les classes des éléments visités en créant de nouveaux visiteurs pour implémenter de nouvelles fonctionnalités.
** ''Exemple'' : Pour une nouvelle fonctionnalité d'exportation XML d'objets 'Cercle' et 'Carré', on crée un 'XmlExportVisitor' sans modifier les classes 'Cercle' ou 'Carré'.
* La logique d'une opération est regroupée dans une seule classe.
** ''Exemple'' : Toutes les règles de calcul de surface pour différents types de 'Forme' sont centralisées dans une seule classe 'CalculSurfaceVisitor'.
* Facilité de la maintenance et la compréhension du code.
** ''Exemple'' : La logique d'impression est regroupée dans une classe 'ImpressionVisitor', facilitant sa modification et sa compréhension.
* On peut ajouter un nouveau comportement qui acceptera les objets de différentes classes.
** ''Exemple'' : Un 'FactureVisitor' peut calculer le total en visitant des objets 'Commande' et 'LigneDeCommande' distincts.
* Le pattern Visiteur encapsule le comportement spécifique à chaque visiteur dans des classes distinctes, permettant de réduire le couplage entre les objets et les opérations.
** ''Exemple'' : La classe 'Cercle' n'a pas à connaître la logique d'exportation JSON, c'est le rôle du 'JsonExportVisitor'.

=== Inconvénients ===
* L'utilisation du pattern Visiteur peut rendre le code plus complexe, s'il y a un grand nombre de classes à visiter ou de visiteurs à implémenter.
** ''Exemple'' : Avec 50 types de 'Document' et 10 visiteurs, cela impliquerait 500 méthodes 'visit()' à gérer.
* Pour ajouter de nouveaux types d'objets à visiter, on doit modifier par exemple l'interface Visitor pour inclure une méthode pour chaque nouveau type.
** ''Exemple'' : L'ajout d'une nouvelle 'Triangle' nécessite de modifier l'interface 'Visitor' et toutes ses implémentations pour ajouter 'visit(Triangle triangle)'.
* Moins adapté pour les structures de données complexes, car il peut nécessiter la création de plusieurs visiteurs pour traiter toutes les opérations souhaitées.
** ''Exemple'' : Pour une structure arborescente complexe, un seul visiteur pourrait être insuffisant, nécessitant plusieurs visiteurs coordonnés.
* Les visiteurs n’ont parfois pas les accès nécessaires aux attributs ou méthodes privés des éléments qu’ils sont censés manipuler.
** ''Exemple'' : Un 'SerializationVisitor' peut avoir besoin d'accéder à un attribut privé 'motDePasse' d'un 'Utilisateur', ce qui peut nécessiter l'exposition de méthodes d'accès publiques non souhaitées.